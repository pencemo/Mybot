const { Bot, InlineKeyboard } = require('grammy');
const mongoose = require('mongoose');

// MongoDB and Mongoose setup
const mongoUri = 'your_mongodb_connection_string'; // Replace with your MongoDB connection string
mongoose.connect(mongoUri, { useNewUrlParser: true, useUnifiedTopology: true })
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => console.error('MongoDB connection error:', err));

// Define schema and model
const messageSchema = new mongoose.Schema({
  id: { type: Number, required: true, unique: true },
  text: [{ text: String }]
});

const Message = mongoose.model('Message', messageSchema);

// Telegram bot setup
const bot = new Bot('your_telegram_bot_token'); // Replace with your Telegram bot token

// Function to fetch and paginate messages
async function fetchMessages(userId, page = 1) {
    const PAGE_SIZE = 8; // Number of messages per page
    const skip = (page - 1) * PAGE_SIZE;
    const messages = await Message.findOne({ id: userId });

    if (!messages) return [];

    return messages.text.slice(skip, skip + PAGE_SIZE);
}

// Function to build pagination keyboard
function buildPaginationKeyboard(userId, page, totalPages) {
    const keyboard = new InlineKeyboard();
    const row = [];
    if (page > 1) {
        row.push({ text: 'Previous', callback_data: `page:${userId}:${page - 1}` });
    }
    if (page < totalPages) {
        row.push({ text: 'Next', callback_data: `page:${userId}:${page + 1}` });
    }
    if (row.length > 0) {
        keyboard.add(...row);
    }
    return keyboard;
}

// Handle the /savedtext command
bot.command('savedtext', async (ctx) => {
    const userId = ctx.from.id;
    const page = 1; // Start with the first page

    // Fetch messages and pagination details
    const messages = await fetchMessages(userId, page);
    const totalMessages = (await Message.findOne({ id: userId }))?.text.length || 0;
    const totalPages = Math.ceil(totalMessages / 8);

    // Build the keyboard with message buttons
    const keyboard = new InlineKeyboard();
    messages.forEach((msg, index) => {
        keyboard.add({ text: `Message ${index + 1}`, callback_data: `msg:${userId}:${msg.text}` });
    });
    // Add pagination controls in a new row
    keyboard.add(buildPaginationKeyboard(userId, page, totalPages));

    // Send the message with buttons
    await ctx.reply('Here are your saved messages:', {
        reply_markup: keyboard
    });
});

// Handle callback queries
bot.on('callback_query', async (ctx) => {
    const data = ctx.callbackQuery.data;
    const [action, userId, ...args] = data.split(':');

    if (action === 'msg') {
        // Send the selected message
        const text = args.join(':');
        await ctx.answerCallbackQuery();
        await ctx.reply(`You selected: ${text}`);
    } else if (action === 'page') {
        const page = parseInt(args[0]);
        const messages = await fetchMessages(userId, page);
        const totalMessages = (await Message.findOne({ id: userId }))?.text.length || 0;
        const totalPages = Math.ceil(totalMessages / 8);

        // Build the keyboard with updated pagination
        const keyboard = new InlineKeyboard();
        messages.forEach((msg, index) => {
            keyboard.add({ text: `Message ${index + 1}`, callback_data: `msg:${userId}:${msg.text}` });
        });
        keyboard.add(buildPaginationKeyboard(userId, page, totalPages));

        await ctx.editMessageText('Here are your saved messages:', {
            reply_markup: keyboard
        });
    }
});

// Start the bot
bot.start();
